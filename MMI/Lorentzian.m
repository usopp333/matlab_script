%% 调整函数的形式：高斯和洛伦兹函数的组合，从图像上来看很相似，f(z)为洛伦兹比高斯平滑，g(z)为高斯比洛伦兹函数值大；
% 过两个定点的形式

% z(z) = g(z) *f(z)    (以下g(z)书写成了f0(z))
%(1).g(z)为洛伦兹函数
%(2).g(z)为高斯函数
%(3).f(z)为洛伦兹函数
%(4).f(z)为高斯函数
clc
clear all
syms A1 A2 A3 b1 b2 b3 z1 z2 z3 z0 x0 zt xt;
x0 = -1.7;
z0 = 0.5;
xt = -1.7;
zt = 1.30;

z1 = z0+0.1;
z2 = (zt+z0)/2;
z3 = zt-0.1;

A1 = 3;
A2 = 1;
A3 = A1;

b1 = 1;
b2 = 3;
b3 = b1;

%f(z) 为洛伦兹函数
f1 = @(z)(A1*b1^2./((z-z1).^2+b1^2));
f2 = @(z)(A2*b2^2./((z-z2).^2+b2^2));
f3 = @(z)(A3*b3^2./((z-z3).^2+b3^2));
% 
% %f(z) 为高斯函数
% f1 = @(z)(A1*exp(-(z-z1)^2./b1^2));
% f2 = @(z)(A2*exp(-(z-z2)^2./b2^2));
% f3 = @(z)(A3*exp(-(z-z3)^2./b3^2));

f = @(z)(f1(z)+f2(z)+f3(z));
M = f(z0)/x0-1;                     %改变g(x)为洛伦兹函数
L = (f(zt)/xt-1)/M;                 %改变g(x)为洛伦兹函数
L_e = log(xt/f(zt))/log(x0/f(z0));  %改变g(x)为高斯函数
a_l = L-1;
b_l = 2*zt-2*L*z0;
c_l = L*z0^2-zt^2;
a_e = L_e-1;
b_e = 2*zt-2*L_e*z0;
c_e = L_e*z0^2-zt^2;
z_0_1_l =  -(b_l + (b_l^2 - 4*a_l*c_l)^(1/2))/(2*a_l);      %z_0_1使用这个解，函数曲线基本上呈现凸
%z_0_1_l = -(2*zt + ((2*zt - (2*z0*(((A1*b1^2)/((z1 - zt)^2 + b1^2) + (A2*b2^2)/((z2 - zt)^2 + b2^2) + (A3*b3^2)/((z3 - zt)^2 + b3^2))/xt - 1))/(((A1*b1^2)/((z0 - z1)^2 + b1^2) + (A2*b2^2)/((z0 - z2)^2 + b2^2) + (A3*b3^2)/((z0 - z3)^2 + b3^2))/x0 - 1))^2 + (zt^2 - (z0^2*(((A1*b1^2)/((z1 - zt)^2 + b1^2) + (A2*b2^2)/((z2 - zt)^2 + b2^2) + (A3*b3^2)/((z3 - zt)^2 + b3^2))/xt - 1))/(((A1*b1^2)/((z0 - z1)^2 + b1^2) + (A2*b2^2)/((z0 - z2)^2 + b2^2) + (A3*b3^2)/((z0 - z3)^2 + b3^2))/x0 - 1))*((4*(((A1*b1^2)/((z1 - zt)^2 + b1^2) + (A2*b2^2)/((z2 - zt)^2 + b2^2) + (A3*b3^2)/((z3 - zt)^2 + b3^2))/xt - 1))/(((A1*b1^2)/((z0 - z1)^2 + b1^2) + (A2*b2^2)/((z0 - z2)^2 + b2^2) + (A3*b3^2)/((z0 - z3)^2 + b3^2))/x0 - 1) - 4))^(1/2) - (2*z0*(((A1*b1^2)/((z1 - zt)^2 + b1^2) + (A2*b2^2)/((z2 - zt)^2 + b2^2) + (A3*b3^2)/((z3 - zt)^2 + b3^2))/xt - 1))/(((A1*b1^2)/((z0 - z1)^2 + b1^2) + (A2*b2^2)/((z0 - z2)^2 + b2^2) + (A3*b3^2)/((z0 - z3)^2 + b3^2))/x0 - 1))/((2*(((A1*b1^2)/((z1 - zt)^2 + b1^2) + (A2*b2^2)/((z2 - zt)^2 + b2^2) + (A3*b3^2)/((z3 - zt)^2 + b3^2))/xt - 1))/(((A1*b1^2)/((z0 - z1)^2 + b1^2) + (A2*b2^2)/((z0 - z2)^2 + b2^2) + (A3*b3^2)/((z0 - z3)^2 + b3^2))/x0 - 1) - 2);
% z_0_1_l = real(z_0_1_l);
z_0_1_e =  -(b_e + (b_e^2 - 4*a_e*c_e)^ (1/2))/(2*a_e);      %z_0_1使用这个解，函数曲线基本上呈现凸
% z_0_1_e = real(z_0_1_e);
%z_0_1_l =  -(b_l - (b_l^2 - 4*a_l*c_l)^(1/2))/(2*a_l);    %z_0_2使用这个解，函数曲线基本上呈现凹
% z_0_1_e =  -(b_e - (b_e^2 - 4*a_e*c_e)^(1/2))/(2*a_e);    %z_0_2使用这个解，函数曲线基本上呈现凹
b_022_l = (z0-z_0_1_l)^2/M;                     %改变g(x)为洛伦兹函数 
b_022_e = -(z0-z_0_1_e)^2/log(x0/f(z0));        %改变g(x)为高斯函数
f0_l = @(z)(b_022_l./((z-z_0_1_l).^2+b_022_l)); %改变g(x)为洛伦兹函数
f0_e = @(z)(exp(-(z-z_0_1_e)^2./b_022_e));      %改变g(x)为高斯函数
x_l = @(z)(f0_l(z)*f(z));                       %改变g(x)为洛伦兹函数
x_e = @(z)(f0_e(z)*f(z));                       %改变g(x)为高斯函数
figure;
z_1 = linspace(z0,zt,100);
x1_l = linspace(z0,zt,100);
x1_e = linspace(z0,zt,100);
% A越大峰值越高
% b越大曲线越平缓，b越小曲线越陡峭，越能分出各个峰
% z各个峰值的位置
 %for A3 = 1
%     delta =  eval(b_l^2-4*a_l*c_l);
    delta =  (b_l^2-4*a_l*c_l);
    if(delta< 0)
        fprintf(1, 'delta = %d', delta);
    end

   for n = 1:100
%        x1_l(n) = eval(f0_l(z_1(n)))*eval(f(z_1(n)));
       x1_l(n) = (f0_l(z_1(n)))*(f(z_1(n)));
      % x1_e(n) = eval(f0_e(z_1(n)))*eval(f(z_1(n)));
   end
   plot(z_1,real(x1_l),'color',[rand rand rand]);hold on
   %plot(z_1,x1_e,'color',[rand rand rand]);

%end
title('z(z) = g(z) *f(z),f(z)为洛伦兹函数');
legend('g(z)洛伦兹函数','g(z)高斯函数');



% % 使用符号计算来计算出函数参数的表达式
% clc
% clear all
% syms A1 A2 A3 b1 b2 b3 z1 z2 z3 z0 x0 zt xt  ;
% z(z) = g(z) *f(z)    (以下g(z)书写成了f0(z))
% f(z) 为洛伦兹函数
% f1 = @(z)(A1*b1^2./((z-z1).^2+b1^2));
% f2 = @(z)(A2*b2^2./((z-z2).^2+b2^2));
% f3 = @(z)(A3*b3^2./((z-z3).^2+b3^2));
% 
% % %f(z) 为高斯函数
% f1 = @(z)(A1*exp(-(z-z1)^2./b1^2));
% f2 = @(z)(A2*exp(-(z-z2)^2./b2^2));
% f3 = @(z)(A3*exp(-(z-z3)^2./b3^2));
% 
% f = @(z)(f1(z)+f2(z)+f3(z));
% M = f(z0)/x0-1;                     %改变g(x)为洛伦兹函数
% L = (f(zt)/xt-1)/M;                 %改变g(x)为洛伦兹函数
% L = log(xt/f(zt))/log(x0/f(z0));    %改变g(x)为高斯函数
% a = L-1;
% b = 2*zt-2*L*z0;
% c = L*z0^2-zt^2;
% delta = b^2-4*a*c;
% start：一种对称曲线模型
% z_0_1_l =  z2;      
% z_0_1_e =  z2;      
% b_022_l = (z0-z_0_1_l)^2/(f(z0)/x0-1);           %改变g(x)为洛伦兹函数 
% b_022_e = -(z0-z_0_1_e)^2/log(x0/f(z0));        %改变g(x)为高斯函数
% end 
% z_0_1 =  -(b + (b^2 - 4*a*c)^(1/2))/(2*a);
% z_0_2 =  -(b - (b^2 - 4*a*c)^(1/2))/(2*a); %z_0的表达式
% b_022 = -(z0-z_0_1)^2/log(x0/f(z0));       %b_0的表达式（高斯)
% b_022_l = (z0-z_0_1)^2/M;
% f0 = @(z)(exp(-(z-z_0_1)^2./b_022));
% x = @(z)(f0(z)*f(z));


%%  使用洛伦兹函数设计一种中心轴对称的曲线模型
clc
clear all
theta = 45;
wg_w = 0.5;
a = 1;
b = 0.8;
z0 = 0.5;
%x0 = 1;
x0 = -b-wg_w;
%zt = a/sin(theta*pi/180);
zt = z0+(b)/sin(theta*pi/180);
%xt = 1;
xt = -b-wg_w;
nz = 100;
z_s = linspace(z0,zt,nz);
z = linspace(z0,2*zt,nz+2);
x_z = linspace(0,xt,nz);
x_z_all = linspace(-xt,xt,nz+2);

A1 = -2;
A2 = 1;
A3 = A1;
b1 = 1;
b3 = b1;

z_r = 0.01;	
z1 = 0.01;
z2 = (zt+z0)/2;
z3 = 2*z2-z1;

b2_2 = (z0-z2)^2/((A2/(x0-A1*b1^2/((z0-z3)^2+b1^2)-A1*b1^2/((z0-z1)^2+b1^2)))-1);

for n = 1:nz
    x_z(n) = (A1*b1^2/((z_s(n)-z1)^2+b1^2)+A2*b2_2/((z_s(n)-z2)^2+b2_2)+A3*b3^2/((z_s(n)-z3)^2+b3^2));
end
% for n = 1:nz
%     z(n) = z_s(n);
%     x_z_all(n) = real(x_z(n))-1;
% end
figure;
plot (z_s,x_z);

%% 使用z(z) = g(z) *f(z)的形式完成一个对称函数曲线模型
% 调整函数的形式：高斯或洛伦兹函数的相互组合，从图像上来看很相似，f(z)为洛伦兹比高斯平滑，g(z)为高斯比洛伦兹函数值大；
% 条件：过两个定点（由于是对称结构，其实对于化简函数这两个对称点作用相当于一个点）
%       函数各个部分的z都可以明确的确定，z0和z2：函数对称轴；z1和z3关于对称轴对称的两个点
% z(z) = g(z) *f(z)    (以下g(z)书写成了f0(z))
%(1).g(z)为洛伦兹函数
%(2).g(z)为高斯函数
%(3).f(z)为洛伦兹函数
%(4).f(z)为高斯函数
clc
clear all
syms A1 A2 A3 b1 b2 b3 z1 z2 z3 z0 x0 zt xt;
theta = 45;
wg_w = 0.5;
a = 1;
b = 0.8;
% down_corner
z0 = 0.5;
%x0 = 0.1;
x0 = -b-wg_w;
%zt = a/sin(theta*pi/180);
zt = z0+(b)/sin(theta*pi/180);
%xt = 0.1;
xt = -b-wg_w;

%up_corner
% z0 = 0;
% x0 = 1;
% zt = a/sin(theta*pi/180);
% xt = 1;

z1 = 1;
z2 = (zt+z0)/2;
z3 = 2*z2-z1;

A1 = -0.1;
A2 = -0.1;
A3 = A1;

b1 = 0.2;
b2 = 0.2;
b3 = b1;

%f(z) 为洛伦兹函数
f1 = @(z)(A1*b1^2./((z-z1).^2+b1^2));
f2 = @(z)(A2*b2^2./((z-z2).^2+b2^2));
f3 = @(z)(A3*b3^2./((z-z3).^2+b3^2));
% 
% %f(z) 为高斯函数
% f1 = @(z)(A1*exp(-(z-z1)^2./b1^2));
% f2 = @(z)(A2*exp(-(z-z2)^2./b2^2));
% f3 = @(z)(A3*exp(-(z-z3)^2./b3^2));

f = @(z)(f1(z)+f2(z)+f3(z));

z_0_1_l =  z2;      
z_0_1_e =  z2;      
b_022_l = (z0-z_0_1_l)^2/(f(z0)/x0-1);           %改变g(x)为洛伦兹函数 
b_022_e = -(z0-z_0_1_e)^2/log(x0/f(z0));        %改变g(x)为高斯函数
f0_l = @(z)(b_022_l./((z-z_0_1_l).^2+b_022_l));  %改变g(x)为洛伦兹函数
f0_e = @(z)(exp(-(z-z_0_1_e)^2./b_022_e));      %改变g(x)为高斯函数
x_l = @(z)(f0_l(z)*f(z));                        %改变g(x)为洛伦兹函数
x_e = @(z)(f0_e(z)*f(z));                       %改变g(x)为高斯函数
figure;
z_1 = linspace(z0,zt,100);
x1_l = linspace(z0,zt,100);
x1_e = linspace(z0,zt,100);
% A越大峰值越高
% b越大曲线越平缓，b越小曲线越陡峭，越能分出各个峰
% z各个峰值的位置
 %for A3 = 1
%     delta =  eval(b_l^2-4*a_l*c_l);
%     delta =  (b_l^2-4*a_l*c_l);
%     if(delta< 0)
%         fprintf(1, 'delta = %d', delta);
%     end

   for n = 1:100
%        x1_l(n) = eval(f0_l(z_1(n)))*eval(f(z_1(n)));
       x1_l(n) = (f0_l(z_1(n)))*(f(z_1(n)));
       x1_e(n) = (f0_e(z_1(n)))*(f(z_1(n)));
   end
  % plot(z_1,real(x1_l),'color',[rand rand rand]);hold on
   plot(z_1,real(x1_e),'color',[rand rand rand]);

%end
title('z(z) = g(z) *f(z),f(z)为洛伦兹函数');
legend('g(z)洛伦兹函数','g(z)高斯函数');


